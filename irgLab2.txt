FPSManager.h => svi podatci o fpsima
U shaderu se odvija učitavanje vertex shadera i fragment shadera, provjerava njihov kod(check 
compiler errors). Zapamti učitavanje stringa iz fajla pomoću stringstream. ID služi za raspoznavanje 
programa, svaki ID je vezan za program. Za set uniform neman pojma ca je to. 
U vjezba3 main.cpp naziv u loadShaderu je ime za shader.vert i shader.frag.
IRG 5. => eksplicitni vs implicitni oblik. Implicitni je pomoću voxela - određivanje da li neka točka
pripada površini, koliko je udaljeno, detekcija sudara itd. Eksplicitni - trokuti, parametarski,
surfeli. Eksplicitni način je za glatke površine - to je parametarski oblik.
Opis zadavanja krilatog brida - 5.predavanje 1:16:00
Triangle strip => neki vrhovi zajednički trokutima => ušteda memorijska, imamo n/2 vrhova umjesto 3*n
GLfloat za neku prenosivost
VBO - podatke spremiti u memoriji na grafičkoj kartici
glGenBuffers => stvaranje VBO spremnika. 
glBindBuffer => aktiviranje spremnika na G kartici
glBufferData => punjenje aktivnog spremnika podatcima
GLuint vertexBuffer; //logička adresa
glGenBuffers => koliko spremnika treba stvoriti, identifikator spremnika
glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer);
glBufferData => prenesi podatke, GL_STATIC_DRAW = >neće se mijenjat
Bez indeksiranja => višestruki podaci, npr. za eksploziju poligona
Indeksirani pristup: zajednički podaci za pojedini vrh
Višestruko indeksirani pristup => poseban pristup normalama, boji i sl., povećan broj indeksa, npr.
normale poligona - konstantno
GL_ELEMENT_ARRAY_BUFFER => indeksirani pristup
VAO => obično imamo više sjenčara svaki sa svojim atributima, omogućuje postavljanje aktivnog sjenčara
s pripadnim atributima


3.labos
Pitanja prije 3.1


1. glfwSetFramebufferSizeCallback => funkcija koja se poziva prilikom mijenjanja veličine prozpra
   Za cursor je isto callback funkcija
2. A Vertex Array Object (VAO) is an object which contains one or more Vertex Buffer Objects and is designed to store the information for a complete rendered object. A Vertex Buffer Object (VBO) is a memory 
   buffer in the high speed memory of your video card designed to hold information about vertices. In our example we have two VBOs, one that describes the coordinates of our vertices and another that describes
   the color associated with each vertex. VBOs can also store information such as normals, texcoords, indicies, etc. glGenVertexArrays =>  returns n vertex array object names in arrays. 
   Najprije se generira pa se tek onda bind-a. glBindVertexArray binds the vertex array object with name array. array is the name of a vertex array object previously returned from a call to glGenVertexArrays,
   or zero to break the existing vertex array object binding.
3. glBufferData => kreira i inicijalizira buffer object's data store
4. glVertexAttribPointer => definira polje generičkih atributa o vrhu. Enable ili disable samo omogućuju da se to koristi ili ne. Pazi npr. za boju onda moramo pisati shader.
5. glVertexAttribDivisor => prvo prima indeks o kojem atributu govorimo, a drugi element je broj instanci koji će proći između ažuriranja atributa na poziciji index.
6. glUseProgram => instalira programski objekt kao dio trenutačnog rendering stanja. U labosu se to koristi kroz shader objekte. 
7. glGetUniformLocation returns an integer that represents the location of a specific uniform variable within a program object. To se nalazi u shader.vert. glUniform3f onda inicijalizira tu varijablu koja se 
   nalazi na toj nekoj lokaciji.
8. glViewport => setupira viewport
9. glDrawArrays => prvi element je sta ce se crtat koji primitivni element, drugi element je početni indeks, a treći element je broj vrhova. Podrazumijeva se da je to već nekako došlo u buffer, a došlo je 
   preko komanda glbufferdata, bindbuffer itd. glDrawElements => to isto crta nešto, ali je drugačiji pristup tome. To je po meni neka naprednija verzija jer omogućuje da se odvoji polje vrhova, normala itd.
   glDrawelementsinstanced  to je n*gldrawelements
10. Shaderi su mali programi koji se vrte po GPU-ima. Svaki program mora minimalno imat vertex i fragment shader. gl_Position je behind the scenes vec4. Svi ti shaderi imaju input i output varijable. U pravim
    aplikacijama se podatci normaliziraju u vertex.shaderu(ne dolaze tamo već normalizirani). layout 0 to ovisi o kojem vertex atributu govorimo. 0 je za poziciju. 
//uniformna varijabla je jednaka svim sjencarima pri jednom pozivu iscrtavanja




Matrice pogleda i projekcije. Očiste je tamo di je oko. Gledište je tamo di gledamo. Viewup vektor
određuje okomicu. 
1. translacija očista u ishodište matricom T.
2. Potrebno je odrediti rotaciju R kojom ćemo podudariti koordinatne osi koordinatnog susava oka i 
globalnog. Pogledaj pravilo desne ruke. Koordinatni sustav oka je obično lijevi pa je potrebni z 
koordinatu zrcaliti odnosno pomnožiti s - 1??? Sustav scene je obično i to mislimo na globalni 
koordinatni sustav. Sustav oka je obično lijevi i to je sustav oka. Najprije ide transformacija pogleda
, onda transf projekcije. Ortografska i perspektivna projekcija i kosa. Tijela koja su bliže promatraču
veća su u projekciji. ModelView = View*Model. View je kamera, a model baš mičeš taj objekt. Valjda je 
z os najbitnija jer u tom smjeru gledamo objekt.

Pitanja:
1. Volumen pogleda ono što se vidi u OpenGLu npr. to je -1 do 1 x3.

3. Odsiječe sve šta je vani. 

6. Nije, potrebna nam je još jedna informacija jer u tom slučaju npr. glavu možemo okretati. View up
   vektor je rješenje.
7. Zadaje kamo da gleda os y'. Npr. neka gleda prema gore šta je u našem slučaju z+. 


Desni vektor je pozitivna x os. 
Gledamo u smjeru negativne z osi!!!
Ja mislim da je lokalno to ca ja gledan znaci promatrac, a globalno world coordinates.







